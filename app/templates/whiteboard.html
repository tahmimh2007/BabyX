<!DOCTYPE html>
<html>
<head>
    <title>Whiteboard Studio</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #ffe8d1;
            color: #0a4d4d;
            text-align: center;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: #e76f51;
        }

        #toolbar {
            margin-bottom: 20px;
            background-color: #fff3e0;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .btn, input[type="file"] {
            background-color: #0a4d4d;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #128080;
        }

        select, input[type="color"], input[type="range"] {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
        }

        #whiteboard {
            border: 3px solid #e76f51;
            background-color: #fdf6f0;
            border-radius: 10px;
            box-shadow: 0 0 12px rgba(0,0,0,0.2);
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <h1>Whiteboard Studio</h1>

    <div id="toolbar">
        <select id="tool">
            <option value="draw">Draw</option>
            <option value="eraser">Eraser</option>
            <option value="line">Line</option>
            <option value="rect">Rectangle</option>
            <option value="circle">Circle</option>
            <option value="fill">Fill</option>
        </select>

        <input type="color" id="color" value="#0a4d4d">
        <input type="range" id="brushSize" min="1" max="30" value="4">
        <input type="file" id="imageLoader" accept="image/*">
        <button class="btn" onclick="clearCanvas()">Clear</button>
        <button class="btn" onclick="saveCanvas()">Save</button>
        <a class="btn" href="{{ url_for('home') }}">Back to Home</a>
    </div>

    <canvas id="whiteboard" width="900" height="600"></canvas>

    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');

        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');
        offscreenCanvas.width = canvas.width;
        offscreenCanvas.height = canvas.height;

        let tool = 'draw';
        let drawing = false;
        let startX = 0, startY = 0;
        let hoverX = 0, hoverY = 0;

        const toolSelect = document.getElementById('tool');
        const colorPicker = document.getElementById('color');
        const brushSize = document.getElementById('brushSize');

        toolSelect.addEventListener('change', () => {
            tool = toolSelect.value;
            canvas.style.cursor = tool === 'eraser' ? 'cell' : 'crosshair';
        });

        canvas.addEventListener('mousedown', e => {
            startX = e.offsetX;
            startY = e.offsetY;
            if (tool === 'draw' || tool === 'eraser') {
                drawing = true;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            } else if (tool === 'line' || tool === 'rect' || tool === 'circle') {
                drawing = true;
                offscreenCtx.clearRect(0, 0, canvas.width, canvas.height);
                offscreenCtx.drawImage(canvas, 0, 0);
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (tool === 'fill') {
                hoverX = e.offsetX;
                hoverY = e.offsetY;
                return;
            }

            if (!drawing) return;
            const x = e.offsetX;
            const y = e.offsetY;

            ctx.lineWidth = brushSize.value;
            ctx.lineCap = 'round';

            if (tool === 'draw' || tool === 'eraser') {
                ctx.strokeStyle = tool === 'draw' ? colorPicker.value : "#fdf6f0";
                ctx.lineTo(x, y);
                ctx.stroke();
            } else if (tool === 'line' || tool === 'rect' || tool === 'circle') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(offscreenCanvas, 0, 0);
                ctx.strokeStyle = colorPicker.value + '88';

                if (tool === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else if (tool === 'rect') {
                    ctx.strokeRect(startX, startY, x - startX, y - startY);
                } else if (tool === 'circle') {
                    const radius = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
                    ctx.beginPath();
                    ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        });

        canvas.addEventListener('mouseup', e => {
            const x = e.offsetX;
            const y = e.offsetY;

            if (tool === 'line' || tool === 'rect' || tool === 'circle') {
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = brushSize.value;
                ctx.lineCap = 'round';

                if (tool === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else if (tool === 'rect') {
                    ctx.strokeRect(startX, startY, x - startX, y - startY);
                } else if (tool === 'circle') {
                    const radius = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
                    ctx.beginPath();
                    ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            if (tool === 'fill') {
                floodFill(x, y, hexToRgba(colorPicker.value));
            }

            if (drawing && (tool === 'draw' || tool === 'eraser')) {
                ctx.closePath();
            }

            drawing = false;
        });

        canvas.addEventListener('mouseout', () => {
            drawing = false;
            ctx.closePath();
        });

        canvas.addEventListener('mousemove', () => {
            if (tool === 'fill') {
                // Optional: implement live highlight of target area
            }
        });

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'whiteboard_drawing.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        document.getElementById('imageLoader').addEventListener('change', function(e) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(e.target.files[0]);
        });

        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            const index = (x, y) => (y * width + x) * 4;

            const targetColor = data.slice(index(startX, startY), index(startX, startY) + 4);

            const matchColor = (i) => {
                return (
                    data[i] === targetColor[0] &&
                    data[i + 1] === targetColor[1] &&
                    data[i + 2] === targetColor[2] &&
                    data[i + 3] === targetColor[3]
                );
            };

            const setColor = (i) => {
                data[i] = fillColor[0];
                data[i + 1] = fillColor[1];
                data[i + 2] = fillColor[2];
                data[i + 3] = 255;
            };

            const stack = [[startX, startY]];

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const i = index(x, y);
                if (!matchColor(i)) continue;

                setColor(i);

                if (x > 0) stack.push([x - 1, y]);
                if (x < width - 1) stack.push([x + 1, y]);
                if (y > 0) stack.push([x, y - 1]);
                if (y < height - 1) stack.push([x, y + 1]);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function hexToRgba(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b, 255];
        }
    </script>
</body>
</html>