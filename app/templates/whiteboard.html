<!DOCTYPE html>
<html>
<head>
    <title>Whiteboard Studio</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/whiteboard.css') }}">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/boxicons@latest/css/boxicons.min.css">
</head>
<body>

<div class="wrapper">
    <div id="toolbar">
        <div class="tool-optn" onclick="setTool('draw', this)">
            <i class="bx bx-pencil bx-md"></i>
        </div>

        <div class="tool-optn" onclick="setTool('eraser', this)">
            <i class="bx bx-eraser bx-md"></i>
        </div>

        <div class="tool-optn" onclick="setTool('line', this)">
            <i class="bx bx-minus bx-md"></i>
        </div>

        <div class="tool-optn" onclick="setTool('rect', this)">
            <i class="bx bx-rectangle bx-md"></i>
        </div>

        <div class="tool-optn" onclick="setTool('circle', this)">
            <i class="bx bx-circle bx-md"></i>
        </div>

        <div class="tool-optn" onclick="setTool('fill', this)">
            <i class="bx bx-color-fill bx-md"></i>
        </div>

        <input type="color" id="color" value="#0a4d4d">
        <input type="range" id="brushSize" min="1" max="30" value="4">
        <input type="file" id="imageLoader" accept="image/*">
        <button class="btn" onclick="clearCanvas()">Clear</button>
        <button class="btn" onclick="saveCanvas()">Save</button>
        <a class="btn" href="{{ url_for('home') }}">Back to Home</a>
    </div>

        <canvas id="whiteboard" style="width: 100%; height: 100%"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');
        offscreenCanvas.width = canvas.width;
        offscreenCanvas.height = canvas.height;

        let tool = 'draw';
        let drawing = false;
        let startX = 0, startY = 0;
        let hoverX = 0, hoverY = 0;

        const colorPicker = document.getElementById('color');
        const brushSize = document.getElementById('brushSize');

        function setTool(selectedTool, element) {
            tool = selectedTool;
            canvas.style.cursor = tool === 'eraser' ? 'cell' : 'crosshair';

            document.querySelectorAll('.tool-optn').forEach(tool => {
                tool.style.backgroundColor = '';
            });

            element.style.backgroundColor = 'rgba(255,255,255,0.2)';
        }

        canvas.addEventListener('mousedown', e => {
            startX = e.offsetX;
            startY = e.offsetY;
            if (tool === 'draw' || tool === 'eraser') {
                drawing = true;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            } else if (tool === 'line' || tool === 'rect' || tool === 'circle') {
                drawing = true;
                offscreenCtx.clearRect(0, 0, canvas.width, canvas.height);
                offscreenCtx.drawImage(canvas, 0, 0);
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (tool === 'fill') {
                hoverX = e.offsetX;
                hoverY = e.offsetY;
                return;
            }

            if (!drawing) return;
            const x = e.offsetX;
            const y = e.offsetY;

            ctx.lineWidth = brushSize.value;
            ctx.lineCap = 'round';

            if (tool === 'draw' || tool === 'eraser') {
                ctx.strokeStyle = tool === 'draw' ? colorPicker.value : "#fdf6f0";
                ctx.lineTo(x, y);
                ctx.stroke();
            } else if (tool === 'line' || tool === 'rect' || tool === 'circle') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(offscreenCanvas, 0, 0);
                ctx.strokeStyle = colorPicker.value + '88';

                if (tool === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else if (tool === 'rect') {
                    ctx.strokeRect(startX, startY, x - startX, y - startY);
                } else if (tool === 'circle') {
                    const radius = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
                    ctx.beginPath();
                    ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        });

        canvas.addEventListener('mouseup', e => {
            const x = e.offsetX;
            const y = e.offsetY;

            if (tool === 'line' || tool === 'rect' || tool === 'circle') {
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = brushSize.value;
                ctx.lineCap = 'round';

                if (tool === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else if (tool === 'rect') {
                    ctx.strokeRect(startX, startY, x - startX, y - startY);
                } else if (tool === 'circle') {
                    const radius = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
                    ctx.beginPath();
                    ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            if (tool === 'fill') {
                floodFill(x, y, hexToRgba(colorPicker.value));
            }

            if (drawing && (tool === 'draw' || tool === 'eraser')) {
                ctx.closePath();
            }

            drawing = false;
        });

        canvas.addEventListener('mouseout', () => {
            drawing = false;
            ctx.closePath();
        });

        canvas.addEventListener('mousemove', () => {
            if (tool === 'fill') {
                // Optional: implement live highlight of target area
            }
        });

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'whiteboard_drawing.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        document.getElementById('imageLoader').addEventListener('change', function(e) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(e.target.files[0]);
        });

        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            const index = (x, y) => (y * width + x) * 4;

            const targetColor = data.slice(index(startX, startY), index(startX, startY) + 4);

            const matchColor = (i) => {
                return (
                    data[i] === targetColor[0] &&
                    data[i + 1] === targetColor[1] &&
                    data[i + 2] === targetColor[2] &&
                    data[i + 3] === targetColor[3]
                );
            };

            const setColor = (i) => {
                data[i] = fillColor[0];
                data[i + 1] = fillColor[1];
                data[i + 2] = fillColor[2];
                data[i + 3] = 255;
            };

            const stack = [[startX, startY]];

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const i = index(x, y);
                if (!matchColor(i)) continue;

                setColor(i);

                if (x > 0) stack.push([x - 1, y]);
                if (x < width - 1) stack.push([x + 1, y]);
                if (y > 0) stack.push([x, y - 1]);
                if (y < height - 1) stack.push([x, y + 1]);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function hexToRgba(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b, 255];
        }
    </script>
</body>
</html>
